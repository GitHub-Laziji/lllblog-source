---
title: js中yield实现同步原理
date: 2019-11-25 21:02:28
categories: 技术分享
tags:
- JavaScript
---


在js中需要将异步方法同步的时候, 经常使用的是`sync`和`await`, 或者用`Promise`


偶然在dvajs中看到其使用`yield`迭代器实现了同步的效果, 例如

```js
function* f(){
  var a = Promise.resolve(1);
  console.log(a); // Promise
  var ra = yield a;
  console.log(ra); // 1
  var b = Promise.resolve(2);
  console.log(b); // Promise
  var rb = yield b;
  console.log(rb); // 2
  return "success";
}
```

当然直接运行不能得到预期的效果, 还缺少对其的一层封装
```js
var it = f();
it.next();
it.next();
it.next();
```


传统的迭代器, 是这样使用的

```js
function* r(){
  for(let i=0;i<n;i++){
    yield i;
  }
}
var it = r();
console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
```



如下封装
```js
function sync(g) {
  var ctx = this;
  return new Promise(function(resolve, reject) {
    g = g.apply(ctx);
    next();
    function next(res) {
      var result = g.next(res);
      if (result.done){
        return resolve(result.value);
      }
      result.value.then(next, null);
    }
  });
}

sync(function*(){
  var a = Promise.resolve(1);
  console.log(a); // Promise
  var ra = yield a;
  console.log(ra); // 1
  var b = Promise.resolve(2);
  console.log(b); // Promise
  var rb = yield b;
  console.log(rb); // 2
  return "success";
}).then(v=>{
  console.log(v) // success
});

```